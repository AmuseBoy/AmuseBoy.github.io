{"meta":{"title":"我的博客","subtitle":"菜鸟一枚，突然想到是时候提高自己了","description":"毕业于山东师范大学，目前在北京工作","author":"Amuse Boy","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2022-04-01T03:23:59.000Z","updated":"2022-04-01T03:23:59.577Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"archives","date":"2020-06-19T10:59:57.000Z","updated":"2020-06-19T12:14:55.733Z","comments":true,"path":"archives/index.html","permalink":"http://yoursite.com/archives/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-06-19T08:57:21.000Z","updated":"2020-06-19T12:14:39.055Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-06-19T07:59:02.000Z","updated":"2020-06-19T12:13:46.914Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"遇到数据库连接socket关闭问题","slug":"遇到数据库连接socket关闭问题","date":"2022-10-14T08:58:35.000Z","updated":"2022-10-14T09:57:03.819Z","comments":true,"path":"2022/10/14/遇到数据库连接socket关闭问题/","link":"","permalink":"http://yoursite.com/2022/10/14/%E9%81%87%E5%88%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5socket%E5%85%B3%E9%97%AD%E9%97%AE%E9%A2%98/","excerpt":"","text":"1. 异常现象连接数据库报错，有时执行sql成功，有时执行sql报错。 12345678910111213141516171819The last packet successfully received from the server was 668,610 milliseconds ago. The last packet sent successfully to the server was 668,612 milliseconds ago. at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62) at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45) at java.lang.reflect.Constructor.newInstance(Constructor.java:423) at com.mysql.cj.exceptions.ExceptionFactory.createException(ExceptionFactory.java:61) at com.mysql.cj.exceptions.ExceptionFactory.createException(ExceptionFactory.java:105) at com.mysql.cj.exceptions.ExceptionFactory.createException(ExceptionFactory.java:151) at com.mysql.cj.exceptions.ExceptionFactory.createCommunicationsException(ExceptionFactory.java:167) at com.mysql.cj.protocol.a.NativeProtocol.clearInputStream(NativeProtocol.java:818) at com.mysql.cj.protocol.a.NativeProtocol.sendCommand(NativeProtocol.java:630) at com.mysql.cj.protocol.a.NativeProtocol.sendQueryPacket(NativeProtocol.java:951) at com.mysql.cj.NativeSession.execSQL(NativeSession.java:1075) at com.mysql.cj.jdbc.ClientPreparedStatement.executeInternal(ClientPreparedStatement.java:930) ... 125 common frames omittedCaused by: java.io.IOException: Socket is closed at com.mysql.cj.protocol.AbstractSocketConnection.getMysqlInput(AbstractSocketConnection.java:72) at com.mysql.cj.protocol.a.NativeProtocol.clearInputStream(NativeProtocol.java:814) ... 129 common frames omitted 2.问题分析从现象来看，连接池获取到连接后，访问数据库，但是这个连接的socket已经关闭了。 我们的jdbc的配置如下,配置了socket超时时间为10分钟，10分钟后，socket就会进行关闭。 1jdbc:mysql:&#x2F;&#x2F;XXXX?autoReconnect&#x3D;true&amp;socketTimeout&#x3D;600000 我们把超时设置去掉，就会恢复正常。 3.思考我们的druid连接池为什么没能清除无效的连接呢？ 我们的druid的配置如下： 123456789druid: ## 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 time-between-eviction-runs-millis: 600000 ## 配置一个连接在池中最小生存的时间，单位是毫秒 min-evictable-idle-time-millis: 300000 ## 申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效 test-while-idle: true ## 用于检查连接有效性SQL validation-query: SELECT 1 暂时不大清楚","categories":[],"tags":[]},{"title":"8种数据结构","slug":"数据结构","date":"2022-04-01T03:02:09.000Z","updated":"2022-04-01T11:15:26.031Z","comments":true,"path":"2022/04/01/数据结构/","link":"","permalink":"http://yoursite.com/2022/04/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"","text":"1.数组数组运算 遍历：遍历所有元素并进行打印。 插入：将一个或多个元素插入数组。 删除：从数组中删除元素 搜索：在数组中搜索元素。您可以按元素的值或索引搜索元素 更新：在给定索引处更新现有元素的值 数组应用 用作构建其他数据结构的基础，例如数组列表，堆，哈希表，向量和矩阵。 用于不同的排序算法，例如插入排序，快速排序，冒泡排序和合并排序。","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"新的文章","slug":"新的文章","date":"2021-12-01T11:37:52.000Z","updated":"2021-12-01T11:37:52.160Z","comments":true,"path":"2021/12/01/新的文章/","link":"","permalink":"http://yoursite.com/2021/12/01/%E6%96%B0%E7%9A%84%E6%96%87%E7%AB%A0/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"SpringBoot+Druid实现多数据源切换","slug":"SpringBoot+Druid实现多数据源切换","date":"2020-06-22T10:03:16.000Z","updated":"2022-11-21T09:57:15.665Z","comments":true,"path":"2020/06/22/SpringBoot+Druid实现多数据源切换/","link":"","permalink":"http://yoursite.com/2020/06/22/SpringBoot+Druid%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E5%88%87%E6%8D%A2/","excerpt":"","text":"1.Druid多数据源配置1234567891011#druid多个数据源配置#onespring.datasource.druid.one.url=jdbc:mysql://localhost:3306/test?serverTimezone=UTC&amp;autoReconnect=true&amp;useUnicode=true&amp;characterEncoding=utf8spring.datasource.druid.one.username=rootspring.datasource.druid.one.password=123456spring.datasource.druid.one.driver-class-name=com.mysql.jdbc.Driver#twospring.datasource.druid.two.url=jdbc:mysql://localhost:3306/test0?serverTimezone=UTC&amp;autoReconnect=true&amp;useUnicode=true&amp;characterEncoding=utf8spring.datasource.druid.two.username=rootspring.datasource.druid.two.password=123456spring.datasource.druid.two.driver-class-name=com.mysql.jdbc.Driver 2.注入多数据源和事物到Spring容器中 启动类 1234567891011@SpringBootApplication@MapperScan(&quot;com.liu.framethree.dao&quot;)@EnableTransactionManagement@EnableAutoConfiguration(exclude&#x3D;&#123;DataSourceAutoConfiguration.class&#125;)&#x2F;&#x2F;增加该注解public class FramethreeApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(FramethreeApplication.class, args); &#125;&#125; 多数据源配置bean 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@Configurationpublic class MultiDruidConfig &#123; private Logger logger = LoggerFactory.getLogger(MultiDruidConfig.class); //@Primary @Bean @ConfigurationProperties(\"spring.datasource.druid.one\") public DruidDataSource dataSourceOne()&#123; return DruidDataSourceBuilder.create().build(); &#125; @Bean @ConfigurationProperties(\"spring.datasource.druid.two\") public DruidDataSource dataSourceTwo()&#123; return DruidDataSourceBuilder.create().build(); &#125; @Bean(value = \"dataSource\") @Primary//首先加载的数据源 public DataSource dataSourceRouter(@Qualifier(\"dataSourceOne\") DruidDataSource dataSourceOne, @Qualifier(\"dataSourceTwo\") DruidDataSource dataSourceTwo)&#123; Map&lt;Object, Object&gt; targetDataSources = new HashMap&lt;&gt;(); targetDataSources.put(\"one\", dataSourceOne); targetDataSources.put(\"two\", dataSourceTwo); DataSourceRouter dataSourceRouter = new DataSourceRouter(); dataSourceRouter.setTargetDataSources(targetDataSources); dataSourceRouter.setDefaultTargetDataSource(dataSourceOne); return dataSourceRouter; &#125; /** * 数据源one的事物 * @param dataSourceOne * @return */ @Bean @Primary//默认数据源事物 public PlatformTransactionManager oneTaxManager(@Qualifier(\"dataSourceOne\") DruidDataSource dataSourceOne)&#123; return new DataSourceTransactionManager(dataSourceOne); &#125; /** * 数据源two的事物 * @param dataSourceTwo * @return */ @Bean public PlatformTransactionManager twoTaxManager(@Qualifier(\"dataSourceTwo\") DruidDataSource dataSourceTwo)&#123; return new DataSourceTransactionManager(dataSourceTwo); &#125;&#125; 3.定义数据源切换注解123456@Target(&#123;ElementType.METHOD,ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface TargetDataSource &#123; String value();&#125; 4.定义数据源切换切面 首先使用ThreadLocal存放数据源切换的对象 12345678910111213141516public class DBContextHolder &#123; private static final ThreadLocal&lt;String&gt; contextHolder &#x3D; new ThreadLocal&lt;&gt;(); public static void setDataSource(String dataSource)&#123; contextHolder.set(dataSource); &#125; public static String getDataSource()&#123; return contextHolder.get(); &#125; public static void clearDataSource()&#123; contextHolder.remove(); &#125;&#125; 定义数据源切换的切面过程 1234567891011121314151617181920212223242526272829@Aspect@Component@Order(-1)&#x2F;&#x2F;设置@TargetDataSource注解在事物注解之前执行public class DataSourceAspect &#123; private Logger logger &#x3D; LoggerFactory.getLogger(DataSourceAspect.class); @Around(&quot;@annotation(targetDataSource)&quot;) public Object proceed(ProceedingJoinPoint proceedingJoinPoint, TargetDataSource targetDataSource) throws Throwable&#123; String value &#x3D; targetDataSource.value(); logger.info(&quot;set database is &#123;&#125;&quot;, value); if(value.equals(&quot;one&quot;))&#123; DBContextHolder.setDataSource(&quot;one&quot;); &#125;else &#123; DBContextHolder.setDataSource(&quot;two&quot;); &#125; return proceedingJoinPoint.proceed(); &#125; &#x2F;** * 用完删除 * @param targetDataSource *&#x2F; @After(&quot;@annotation(targetDataSource)&quot;) public void clearDataSource(TargetDataSource targetDataSource)&#123; logger.info(&quot;delete dataSource&quot;); DBContextHolder.clearDataSource(); &#125;&#125; 继承AbstractRoutingDataSource类，实现获取当前数据源变量的接口。 12345678910public class DataSourceRouter extends AbstractRoutingDataSource &#123; private Logger logger &#x3D; LoggerFactory.getLogger(DataSourceRouter.class); @Override protected Object determineCyingurrentLookupKey() &#123; logger.info(&quot;now dataSource is &#123;&#125;&quot;, DBContextHolder.getDataSource()); return DBContextHolder.getDataSource(); &#125;&#125; 5.使用方式 在我们的代码中，我们定义了2个事物Bean，分表是oneTaxManager，twoTaxManager，分表对应的数据源是one和two，例如如下使用： 12345@Transactional(value = \"twoTaxManager\")@TargetDataSource(\"two\")public List&lt;User&gt; getUserList() &#123; return userMapper.getUserList();&#125; 6.注意事项(1).数据源切换执行时机 我们在类DataSourceAspect增加注解@Order(-1)//设置@TargetDataSource注解在事物注解@Transactional之前执行，如果在执行事物切面之前，没有指定数据源，事物就会使用默认的数据源。 (2).事物内切换数据源不生效，定义多个事物 代码中配置多个事物的原因，当我们使用@Transactional注解后，在一个事物内，是不会再切换数据源的，系统会使用已经设置过的缓存数据源。如果在一个事物内，先后使用2个数据源，第二个数据源切换并不会生效，造成系统异常。 123456789101112&#x2F;&#x2F;在事物内，切换数据源为two@Transactional(value &#x3D; &quot;twoTaxManager&quot;)@TargetDataSource(&quot;two&quot;)public List&lt;User&gt; getUserList() &#123; return otherService.getUserList();&#125;&#x2F;&#x2F;另外一个Class类的方法,此时在上个方法的事物内，数据源不会切换会one@TargetDataSource(&quot;one&quot;)public List&lt;User&gt; getUserList() &#123; return userMapper.getUserList();&#125; 要想使我们的切换数据源生效，我们需要另外开启一个事物，或者使用不同的数据源事务。 123456@Transactional(value &#x3D; &quot;oneTaxManager&quot;)&#x2F;&#x2F;使用不同的数据库事务,第一种方式@Transactional(propagation &#x3D; Propagation.REQUIRES_NEW)&#x2F;&#x2F;第二种方式 @TargetDataSource(&quot;one&quot;) public List&lt;User&gt; getUserList() &#123; return userMapper.getUserList(); &#125; 我们也可以不用定义多个事物，使用注解@Transactional(propagation = Propagation.REQUIRES_NEW)同样能达到我们想要的目的。总之在一个事物内，我们变更数据源，系统不会调用我们的determineCurrentLookupKey方法。 (3).不使用事物注解，只定义数据源12345678910 @TargetDataSource(&quot;two&quot;) public List&lt;User&gt; getUserList() &#123; userMapper.getUser(82); return otherService.getUserList(); &#125;&#x2F;&#x2F;另一个类的方法。 public List&lt;User&gt; getUserList() &#123; return userMapper.getUserList(); &#125; 不增加事务注解，此时，所有的dao底层再执行事物操作时，会调用determineCyingurrentLookupKey查询我们的指定数据源，来进行数据库操作。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"drds","slug":"drds","permalink":"http://yoursite.com/tags/drds/"}]},{"title":"DRDS使用问题归集","slug":"DRDS使用问题归集","date":"2020-06-22T09:30:59.000Z","updated":"2020-06-22T10:32:32.200Z","comments":true,"path":"2020/06/22/DRDS使用问题归集/","link":"","permalink":"http://yoursite.com/2020/06/22/DRDS%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E5%BD%92%E9%9B%86/","excerpt":"","text":"DRDS简介 drds是阿里的分库分表的数据库 DRDS使用过程中遇到的问题 DRDS不支持相关的sql语法 drds不支持类似这种语法，select (@i:=@i+1) as no from (select @i:=0) as it; 如果代码中要求查询数据库返回序号的情况，需要在代码中实现。 DRDS批量执行sql报错 我们在代码中需要批量插入数据。一般情况有2种方式。 第一种：insert into xxx values (a,b,c),(c,d,e); 第二种：insert into xxx values (a,b,c);insert into xxx values (c,d,e); 我们并不建议使用第二种方式，但是RDS是支持第二种方式批量插入。 []: 我们在使用DRDS数据库插入时，却报错了，错误代码如： Cause: java.sql.SQLException: [10bf434b34020000-2][172.16.163.190:3306][jx_drds]TddlNestableRuntimeExceptio 该问题是阿里的DRDS内部程序bug,需要寻求技术解决。 DRDS切换数据源 见DRDS数据源切换 DRDS批量插入数据库失败 报错：[TDDL-4603][ERR_ACCROSS_DB_TRANSACTION] Transaction accross db is not supported in current 大意是事物不能跨越数据库，仔细研究代码发现，我是批量插入数据库。sql: insert into student(name,grade,age)values (&#39;a&#39;,&#39;b&#39;,&#39;c&#39;);insert into student(name,grade,age)values (&#39;d&#39;,&#39;e&#39;,&#39;f&#39;); 其中grade字段为sharding-key,即为拆分键，上面的sql根据拆分键需要在不同的数据库进行执行，但是DRDS不支持分布式事物，所以报上述的错误。 我们在代码中如果遇到类似的问题，需要拆分多个事物进行操作。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"drds","slug":"drds","permalink":"http://yoursite.com/tags/drds/"},{"name":"错误","slug":"错误","permalink":"http://yoursite.com/tags/%E9%94%99%E8%AF%AF/"}]},{"title":"Spring的代理","slug":"Spring的代理","date":"2020-06-19T09:02:07.000Z","updated":"2022-11-21T09:22:23.716Z","comments":true,"path":"2020/06/19/Spring的代理/","link":"","permalink":"http://yoursite.com/2020/06/19/Spring%E7%9A%84%E4%BB%A3%E7%90%86/","excerpt":"","text":"1.问题描述 启动项目时，遇到如下的问题，提示使用 proxyTargetClass=true 12345678Description:The bean 'hdog11' could not be injected as a 'com.liu.framethree.config.Hdog' because it is a JDK dynamic proxy that implements: com.liu.framethree.config.DogAction:Consider injecting the bean as one of its interfaces or forcing the use of CGLib-based proxies by setting proxyTargetClass=true on @EnableAsync and/or @EnableCaching. 2.项目代码贴一下 接口Dog 1234567public interface Dog &#123; void run(); void eat();&#125; 接口实现类大黄狗 1234567891011121314151617@Servicepublic class Hdog implements Dog &#123; public Hdog()&#123; &#125; @Override public void run() &#123; &#125; @Async //异步注解 @Override public void eat() &#123; &#125;&#125; 配置类 12345@Configuration@EnableAsync(proxyTargetClass=false)public class Config &#123;&#125; 在代码中引入Dog的bean 12@Autowiredprivate Hdog hdog;//引用变量不是接口名，是实现类 以上代码在启动项目时，即会报上面的错误 3.Spring使用的动态代理 注解@Async，@Transactional是面向切面编程，即AOP的一种使用方式。AOP的实现使用了二种动态代理。 JDK动态代理 CGLIB动态代理 spring会根据代码的实际情况，自动选择来使用哪种代理。 如果代理的对象实现了接口，默认情况下会采用JDK的动态代理。 如果目标对象实现了接口，可以手动强制使用CGLIB代理 如果目标对象没有实现接口，spring会采用CGLIB代理。 设置代理可以通过手动指定，@EnableAsync(proxyTargetClass=true)，默认是false，即JDK代理，true即为CGLIB代理 4.错误分析 在我们的代码中，我们使用了@Async注解，并且在配置类中指定了代理为JDK代理，@EnableAsync(proxyTargetClass=false)，可是我们在引用Dog的bean时，引用的是实现类，并不是接口类， @Autowired private Hdog hdog;，这样引用只能使用CGLIB代理，和我们的系统配置默认JDK代理冲突，所以报错。 注：代理的基于对象层面的，一个对象只能选择一种代理方式 我们可以去掉手动指定代理方式(proxyTargetClass=false)，让spring根据实际的情况选择代理的方式。 经过测试依旧报错。往下看 5.Spring选择代理的过程 当我们把上面的指定代理方式去掉了，认为应该正常了，但是确实还是报错。 那是因为spring加载类文件是有顺序的，spring会先解析Hdog的类文件，即先加载@Async注解，在此过程，默认使用JDK的代理方式，但是当执行到注入bean到@Autowired private Hdog hdog;时，该对象发现使用JDK代理没法注入，必须使用CGLIB代理注入，这时冲突了导致程序异常。 所以我们必须手动指定代理方式为CGLIB代理(proxyTargetClass=false)。 6.实际项目的情况 实际项目我引用了第三方的包，第三方包的类文件含有@Async(&quot;messageTaskExecutor&quot;)注解，我在代码中引入第三方包实现类的bean,不是接口。 12@Autowiredprivate DDMessage ddMessage; 当我没有扫描第三方包时，启动正常，类注入bean默认会使用CGLIB代理，@Async注解不会生效。 当我扫描第三方的包时，启动报错代理异常，@Async注解生效，先加载@Async注解使用JDK代理，再注入bean使用JDK代理报异常。 当我增加注解@EnableAsync，并不扫描第三方包时，启动报错代理异常，@Async注解生效，先加载@Async注解使用JDK代理，再注入bean使用JDK代理报异常。和第二种情况类似。 当我增加注解@EnableAsync(proxyTargetClass=true)，并不扫描第三方包时，启动正常，@Async注解和注入bean都使用CGLIB代理。但是运行报错，没有找到bean messageTaskExecutor,因为没有扫描包。 当我增加注解@EnableAsync(proxyTargetClass=true)，并且扫描第三方包时，一切正常。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"hexo搭建个人博客","slug":"hexo搭建个人博客","date":"2020-06-19T02:34:30.000Z","updated":"2020-06-19T11:41:48.787Z","comments":true,"path":"2020/06/19/hexo搭建个人博客/","link":"","permalink":"http://yoursite.com/2020/06/19/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","excerpt":"1. 工具准备 本地git工具，使用git bash客户端命令行操作","text":"1. 工具准备 本地git工具，使用git bash客户端命令行操作 本地安装node.js，并安装npm包管理器 注册www.github.com的账号 2. 搭建博客下载hexo工具包1npm install -g hexo 初始化博客目录12cd E:\\AmuseBoy.github.io #博客根目录就是AmuseBoy.github.iohexo init #hexo会生成相关的依赖和文件目录等 启动本地博客12hexo g #编译代码hexo s #启动服务,访问 http://localhost:4000/查看页面 上传至github首先在github网站，创建一个项目叫AmuseBoy.github.io , AmuseBoy是github用户名。另外本地博客的文件夹根目录必须也是叫AmuseBoy.github.io，必须一致。在博客的目录下，配置_config.yml文件，增加以下内容, 1234deploy: type: git repo: https://github.com/AmuseBoy/AmuseBoy.github.io.git branch: master 下载hexo-deployer-git插件,用于上传并部署博客代码。 1npm install hexo-deployer-git --save 开始上传代码 1hexo d 然后使用github的三级域名，打开自己的博客网页:https://amuseboy.github.io/ 3. 常用的hexo命令12345678hexo new \"如何像马云一样有钱\" #创建新文章hexo new page \"pageName\" #新建一个页面 hexo generate #编译生成html页面hexo server #启动本地博客服务，端口默认4000hexo deploy #上传服务到githubhexo help #查看帮助hexo version #查看hexo的版本hexo clean #清除缓存文件 db.json 和已生成的静态文件 public 缩写 1234hexo n &#x3D;&#x3D; hexo newhexo g &#x3D;&#x3D; hexo generatehexo s &#x3D;&#x3D; hexo serverhexo d &#x3D;&#x3D; hexo deploy 4. hexo图片的使用写博客时，在引入图片会不免使用绝对路径来引入图片，这种方式很不好管理。我们使用相对路径来管理我们的图片，首先更改成如下配置：_config.yml, post_asset_folder:true 下载插件： 1npm install https://github.com/CodeFalling/hexo-asset-image --save 执行命令 $ hexo new post_name，在 source/_posts 中会生成文章 post_name.md 和同名文件夹 post_name。将图片资源放在 post_name 中，文章就可以使用相对路径引用图片资源了,如/hexo搭建个人博客/hexo-post-1.png.","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"博客","slug":"博客","permalink":"http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-06-13T08:40:08.438Z","updated":"2020-06-19T10:59:08.124Z","comments":true,"path":"2020/06/13/hello-world/","link":"","permalink":"http://yoursite.com/2020/06/13/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"drds","slug":"drds","permalink":"http://yoursite.com/tags/drds/"},{"name":"错误","slug":"错误","permalink":"http://yoursite.com/tags/%E9%94%99%E8%AF%AF/"},{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"博客","slug":"博客","permalink":"http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"}]}